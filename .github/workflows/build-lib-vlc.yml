name: build-lib-vlc

on:
  workflow_dispatch:
  workflow_call:

env:
  SOURCE_REPO: 'https://github.com/videolan/vlc-android.git'
  # SOURCE_BRANCH: 'libvlc-3.6.5'
  SOURCE_BRANCH: 'master'
  BUILD_DIR: 'vlc-android-source'
  GRADLE_VERSION: '8.13'

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Clean runner environment
        run: |
          rm -rf ~/.gradle/caches/transforms-*
          rm -rf ~/.android/build-cache/
          
      - name: Checkout ci repo
        uses: actions/checkout@main

      - name: Initialization values
        run: |
          echo "BUILD_DATE=$(TZ=UTC-8 date +"%y.%m.%d-%H.%M.%S")" >> $GITHUB_ENV

      - name: Clone source repository
        run: |
          echo "Cloning source repository..."
          # 使用更彻底的清理，避免残留文件导致问题
          rm -rf "${{ env.BUILD_DIR }}"
          git clone --depth 1 --branch "${{ env.SOURCE_BRANCH }}" "${{ env.SOURCE_REPO }}" "${{ env.BUILD_DIR }}"




      - name: Setup java 17
        uses: actions/setup-java@main
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'gradle'

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            automake autopoint cmake build-essential libtool \
            patch pkg-config ragel subversion unzip git \
            flex python3 python3-pip wget ninja-build meson nasm yasm \
            libssl-dev protobuf-compiler gettext

      - name: Configure android environment and project
        run: |
          cd "${{ env.BUILD_DIR }}"
          echo "=== 配置 Android 构建环境 ==="
          
          # 1. 验证安装的 NDK 版本和路径
          echo "检查 NDK 安装:"
          if [ -n "$ANDROID_NDK_ROOT" ]; then
            echo "ANDROID_NDK_ROOT: $ANDROID_NDK_ROOT"
            ls -la $ANDROID_NDK_ROOT/ || echo "无法列出 NDK 目录"
            # 检查 ndk-build 版本
            if [ -f "$ANDROID_NDK_ROOT/ndk-build" ]; then
              echo "NDK-Build 版本信息:"
              $ANDROID_NDK_ROOT/ndk-build --version | head -5 || echo "无法获取 ndk-build 版本"
            fi
          else
            echo "警告: ANDROID_NDK_ROOT 未设置"
            # 尝试推断常见路径
            if [ -d "$ANDROID_HOME/ndk" ]; then
              export ANDROID_NDK_ROOT="$(find $ANDROID_HOME/ndk -maxdepth 1 -type d | head -2 | tail -1)"
              echo "推断 ANDROID_NDK_ROOT 为: $ANDROID_NDK_ROOT"
            fi
          fi

          # 2. 配置 Git 身份（解决之前的补丁应用问题）
          git config --global user.email "ci@github-actions"
          git config --global user.name "GitHub Actions"
          
          # 3. 确保脚本所需的环境变量（关键）
          # actions/setup-android 设置的是 ANDROID_NDK_ROOT，但 VLC 脚本可能期望 ANDROID_NDK
          export ANDROID_SDK="$ANDROID_SDK_ROOT"
          export ANDROID_NDK="$ANDROID_NDK_ROOT"
          echo "导出编译变量:"
          echo "  ANDROID_SDK=$ANDROID_SDK"
          echo "  ANDROID_NDK=$ANDROID_NDK"
          
          # 4. 创建 Gradle 的 local.properties
          echo "sdk.dir=$ANDROID_SDK_ROOT" > local.properties
          echo "ndk.dir=$ANDROID_NDK_ROOT" >> local.properties
          echo "✅ 创建 local.properties"
          
          # 5. 初始化 Gradle wrapper
          ./gradlew wrapper --gradle-version=${{ env.GRADLE_VERSION }} --distribution-type=all --quiet 2>/dev/null || true
          
          echo "✅ 环境配置完成"

      # 新增步骤：获取并修改VLC源代码（在构建之前）
      - name: Fetch and modify vlc source code
        run: |
          cd "${{ env.BUILD_DIR }}"
          echo "=== 获取并修改 VLC 源代码 ==="
          
          # 1. 首先获取VLC源代码（通过get-vlc.sh）
          echo "获取VLC核心代码..."
          (cd libvlcjni && ./buildsystem/get-vlc.sh) || {
            echo "get-vlc.sh执行失败，尝试手动获取..."
            # 如果失败，手动克隆VLC
            if [ ! -d "libvlcjni/vlc" ]; then
              echo "手动克隆VLC代码..."
              git clone https://code.videolan.org/videolan/vlc.git libvlcjni/vlc
            fi
          }
          
          # 2. 确认VLC源代码已获取
          if [ ! -d "libvlcjni/vlc" ]; then
            echo "错误: VLC源代码目录不存在"
            exit 1
          fi
          
          VLC_SRC_DIR="libvlcjni/vlc"
          echo "VLC源代码位置: $VLC_SRC_DIR"
          
          # 3. 应用修改
          echo "应用自定义修改..."
          
          # 修改 /lib/core.c
          echo "修改 /lib/core.c..."
          CORE_C_FILE="$VLC_SRC_DIR/lib/core.c"
          if [ -f "$CORE_C_FILE" ]; then
            # 备份原文件
            cp "$CORE_C_FILE" "$CORE_C_FILE.backup"
            
            # 查找并替换
            sed -i 's/&& (asprintf (\&str, "%s LibVLC\/"PACKAGE_VERSION, http) != -1))/&& (asprintf (\&str, "%s abc_media_editor", http) != -1))/' "$CORE_C_FILE"
            
            # 验证修改
            if grep -q "abc_media_editor" "$CORE_C_FILE"; then
              echo "✅ /lib/core.c 修改成功"
            else
              echo "⚠️  /lib/core.c 可能未成功修改"
            fi
          else
            echo "❌ /lib/core.c 文件不存在"
          fi
          
          # 修改 /src/libvlc.c - 第一处
          echo "修改 /src/libvlc.c - 第一处..."
          LIBVLC_C_FILE="$VLC_SRC_DIR/src/libvlc.c"
          if [ -f "$LIBVLC_C_FILE" ]; then
            # 备份原文件
            cp "$LIBVLC_C_FILE" "$LIBVLC_C_FILE.backup"
            
            # 替换第一处
            sed -i 's/"VLC media player (LibVLC "VERSION")"/"abc media editor"/' "$LIBVLC_C_FILE"
            
            # 验证第一处修改
            if grep -q "abc media editor" "$LIBVLC_C_FILE"; then
              echo "✅ /src/libvlc.c 第一处修改成功"
            else
              echo "⚠️  /src/libvlc.c 第一处可能未成功修改"
            fi
          else
            echo "❌ /src/libvlc.c 文件不存在"
          fi
          
          # 修改 /src/libvlc.c - 第二处
          echo "修改 /src/libvlc.c - 第二处..."
          if [ -f "$LIBVLC_C_FILE" ]; then
            # 替换第二处
            sed -i 's/"VLC\/"PACKAGE_VERSION" LibVLC\/"PACKAGE_VERSION/"abc\/abc_media_editor\/"/' "$LIBVLC_C_FILE"
            
            # 验证第二处修改
            if grep -q "abc/abc_media_editor/" "$LIBVLC_C_FILE"; then
              echo "✅ /src/libvlc.c 第二处修改成功"
            else
              echo "⚠️  /src/libvlc.c 第二处可能未成功修改"
            fi
          fi
          
          # 修改 /modules/access/live555.cpp
          echo "修改 /modules/access/live555.cpp..."
          LIVE555_FILE="$VLC_SRC_DIR/modules/access/live555.cpp"
          if [ -f "$LIVE555_FILE" ]; then
            # 备份原文件
            cp "$LIVE555_FILE" "$LIVE555_FILE.backup"
            
            # 查找并替换
            sed -i 's/"LibVLC\/" VERSION/"abc_media_editor"/' "$LIVE555_FILE"
            
            # 验证修改
            if grep -q "abc_media_editor" "$LIVE555_FILE"; then
              echo "✅ /modules/access/live555.cpp 修改成功"
            else
              echo "⚠️  /modules/access/live555.cpp 可能未成功修改"
            fi
          else
            echo "❌ /modules/access/live555.cpp 文件不存在"
          fi
          
          # 4. 最终验证
          echo "=== 最终修改验证 ==="
          echo "1. /lib/core.c:"
          grep -n "abc_media_editor" "$CORE_C_FILE" 2>/dev/null || echo "未找到"
          
          echo -e "\n2. /src/libvlc.c (第一处):"
          grep -n "abc media editor" "$LIBVLC_C_FILE" 2>/dev/null || echo "未找到"
          
          echo -e "\n3. /src/libvlc.c (第二处):"
          grep -n "abc/abc_media_editor/" "$LIBVLC_C_FILE" 2>/dev/null || echo "未找到"
          
          echo -e "\n4. /modules/access/live555.cpp:"
          grep -n "abc_media_editor" "$LIVE555_FILE" 2>/dev/null || echo "未找到"
          
          echo -e "\n✅ VLC源代码修改完成"

      # 为每个架构构建
      - name: Build libvlc for arm64-v8a
        run: |
          cd "${{ env.BUILD_DIR }}"
          echo "开始构建 ARM64 (arm64-v8a) 架构..."
          
          export ANDROID_SDK="$ANDROID_SDK_ROOT"
          export ANDROID_NDK="$ANDROID_NDK_ROOT"
          
          # 首次构建时，使用 -t 参数尝试使用预构建的贡献库以节省大量时间
          # 如果预构建库不存在，脚本会自动回退到源码编译
          time ./buildsystem/compile.sh -l -a arm64 --release -t 2>&1 | tee build_arm64.log
          
          # 检查构建结果
          if ls libvlcjni/libvlc/build/outputs/aar/*.aar 1> /dev/null 2>&1; then
            echo "✅ ARM64 AAR 构建成功！"
            cp libvlcjni/libvlc/build/outputs/aar/*.aar ../libvlc-arm64.aar
          else
            echo "⚠️  未找到ARM64 AAR文件。查看构建日志末尾:"
            tail -100 build_arm64.log
            exit 1 # 使步骤失败
          fi

      - name: Download and setup ndk r21 for armeabi-v7a build need
        run: |
          # 1. 创建 NDK 目录
          mkdir -p $ANDROID_SDK_ROOT/ndk
          # 2. 下载官方 NDK r21 (以 Linux 64位为例)
          wget -q https://dl.google.com/android/repository/android-ndk-r21e-linux-x86_64.zip
          # 3. 解压到 SDK 的 ndk 目录下，并重命名为固定路径
          unzip -q android-ndk-r21e-linux-x86_64.zip -d $ANDROID_SDK_ROOT/ndk/
          mv $ANDROID_SDK_ROOT/ndk/android-ndk-r21e $ANDROID_SDK_ROOT/ndk/21.0.0
          # 4. 设置环境变量（后续步骤和 compile.sh 都需要）
          echo "ANDROID_NDK=$ANDROID_SDK_ROOT/ndk/21.0.0" >> $GITHUB_ENV
          echo "NDK_ROOT=$ANDROID_SDK_ROOT/ndk/21.0.0" >> $GITHUB_ENV

      - name: Build libvlc for armeabi-v7a
        run: |
          cd "${{ env.BUILD_DIR }}"
          echo "清理前一次构建的中间产物..."
          rm -rf libvlcjni/libvlc/build/outputs/aar/*.aar 2>/dev/null || true

          echo "检查当前 NDK 环境..."
          # 备份并移除可能冲突的 NDK
          if [ -d "$ANDROID_SDK_ROOT/ndk-bundle" ]; then
            echo "发现 ndk-bundle，可能引起冲突，重命名..."
            mv "$ANDROID_SDK_ROOT/ndk-bundle" "$ANDROID_SDK_ROOT/ndk-bundle.backup"
          fi

          # 设置正确的环境变量 - 这是关键！
          export ANDROID_NDK="${{ env.ANDROID_NDK }}"
          export ANDROID_SDK="$ANDROID_SDK_ROOT"
          export ANDROID_NDK_ROOT="${{ env.ANDROID_NDK }}"
          export ANDROID_SDK_ROOT="$ANDROID_SDK_ROOT"
    
          # 打印环境变量用于调试
          echo "=== 环境变量检查 ==="
          echo "ANDROID_NDK: $ANDROID_NDK"
          echo "ANDROID_SDK: $ANDROID_SDK"
          echo "ANDROID_NDK_ROOT: $ANDROID_NDK_ROOT"
          echo "ANDROID_SDK_ROOT: $ANDROID_SDK_ROOT"

          # 验证使用的 NDK
          echo "使用的 NDK 路径: $ANDROID_NDK"
          $ANDROID_NDK/ndk-build --version | head -5

          # 更新 local.properties
          echo "sdk.dir=$ANDROID_SDK_ROOT" > local.properties
          echo "ndk.dir=$ANDROID_NDK" >> local.properties

          echo "开始构建 ARMv7 (armeabi-v7a) 架构..."
          # 先检查脚本是否存在
          if [ ! -f "./buildsystem/compile.sh" ]; then
            echo "错误: compile.sh 脚本不存在！"
            exit 1
          fi
    
          # 给脚本添加执行权限
          chmod +x ./buildsystem/compile.sh
    
          # 在命令行中直接传递环境变量
          time ANDROID_NDK="$ANDROID_NDK" ANDROID_SDK="$ANDROID_SDK" \
              ./buildsystem/compile.sh -l -a arm --release -t -b 2>&1 | tee build_armv7.log

          if ls libvlcjni/libvlc/build/outputs/aar/*.aar 1> /dev/null 2>&1; then
            echo "✅ ARMv7 AAR 构建成功！"
            cp libvlcjni/libvlc/build/outputs/aar/*.aar ../libvlc-armv7.aar
          else
            echo "❌ 未找到ARMv7 AAR文件。关键错误如下:"
            grep -A 10 -B 5 -i "error\|failed\|ndk\|could not\|v21 needed" build_armv7.log | head -100
            exit 1
          fi

      - name: Merge aars and verify
        if: always() # 即使上一步有警告也继续执行
        run: |
          echo "准备合并AAR文件..."
          cd "${{ env.BUILD_DIR }}"
          
          # 查找所有可能生成的AAR文件
          find . -name "*.aar" -type f -exec cp {} ../ \;
          cd ..
          
          echo "找到的AAR文件："
          ls -la *.aar 2>/dev/null || { echo "未找到任何AAR文件，构建可能失败。"; exit 1; }
          
          # 智能合并：自动识别基础包和架构包
          /bin/bash -c '
          aars=(*.aar)
          if [ ${#aars[@]} -lt 1 ]; then
              exit 1
          fi
          # 尝试找到一个包含“all”或版本号最全的作为基础包
          BASE_AAR=""
          for aar in "${aars[@]}"; do
              if [[ "$aar" == *"all"* ]] || [[ "$aar" == *"release"* ]]; then
                  BASE_AAR="$aar"
                  break
              fi
          done
          if [ -z "$BASE_AAR" ]; then
              BASE_AAR="${aars[0]}"
          fi
          
          echo "使用 $BASE_AAR 作为基础包进行合并"
          mkdir -p merged-aar
          unzip -q "$BASE_AAR" -d merged-aar
          
          for aar in "${aars[@]}"; do
              if [ "$aar" != "$BASE_AAR" ]; then
                  echo "合并架构库从: $aar"
                  unzip -q -u "$aar" -d merged-aar 2>/dev/null || true
              fi
          done
          
          cd merged-aar
          zip -qr ../libvlc-release.aar .
          cd ..
          
          echo "✅ 合并完成！最终产物: libvlc-release.aar"
          echo "包含的架构:"
          unzip -l libvlc-release.aar | grep "jni/.*/" | cut -d"/" -f2 | sort -u || echo "无法列出架构"
          '

      - name: Create github release
        uses: softprops/action-gh-release@master
        with:
          tag_name: ${{env.BUILD_DATE}}-vlclib
          files: |
            libvlc-release.aar
            libvlc-arm64.aar
            libvlc-armv7.aar
          draft: false
          prerelease: false

      - name: Push vlc aar to bv-libs repository
        env:
          TARGET_REPO: "git@github.com:zxgv5/bv-libs.git"
        run: |
          # 设置 SSH 密钥和配置
          echo "Setting up SSH configuration..."
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # 写入私钥
          echo "${{ secrets.BV_LIBS_DEPLOY_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          
          # 配置 SSH 不验证主机
          echo "Host github.com" >> ~/.ssh/config
          echo "  StrictHostKeyChecking no" >> ~/.ssh/config
          echo "  UserKnownHostsFile /dev/null" >> ~/.ssh/config
          chmod 600 ~/.ssh/config
          
          # 测试 SSH 连接
          echo "Testing SSH connection to GitHub..."
          ssh -T git@github.com 2>&1 | grep -v "successfully authenticated" || true
          
          # 设置 Git 配置
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git config --global init.defaultBranch main
          
          # 克隆目标仓库
          cd "$GITHUB_WORKSPACE"
          echo "Cloning target repository: ${{ env.TARGET_REPO }}"
          git clone ${{ env.TARGET_REPO }} target-repo
          cd target-repo
          
          # 确保在 main 分支
          git checkout main
          
          # 复制新的 AAR 文件到目标位置
          SOURCE_AAR="$GITHUB_WORKSPACE/libvlc-release.aar"
          TARGET_DIR="libVLC"
          
          # 检查 AAR 文件是否存在
          if [ -f "$SOURCE_AAR" ]; then
            echo "✓ Found AAR file: $SOURCE_AAR"
            
            # 确保目标目录存在
            mkdir -p "$TARGET_DIR"
            
            # 复制新文件
            echo "Copying new AAR file..."
            cp -v "$SOURCE_AAR" "$TARGET_DIR/libvlc-release.aar"
            
            # 提交更改
            echo "Committing changes..."
            git add "$TARGET_DIR/libvlc-release.aar"
            
            # 检查是否有更改
            if git diff --cached --quiet; then
              echo "No changes to commit."
            else
              git commit -m "Update VLC AAR (multi-arch: arm64+v7a) - ${{ env.BUILD_DATE }} [CI]"
              echo "Pushing to remote repository..."
              git push origin main
              echo "✓ Successfully pushed multi-architecture VLC AAR to ${{ env.TARGET_REPO }}"
            fi
          else
            echo "✗ Error: AAR file not found at $SOURCE_AAR"
            exit 1
          fi
          
          # 清理 SSH 密钥
          rm -f ~/.ssh/id_ed25519
          rm -f ~/.ssh/config

      # 可选：缓存构建结果以加速后续构建
      # - name: Cache build artifacts
      #   uses: actions/cache@main
      #   with:
      #     path: |
      #       ~/.gradle/caches
      #       ~/.gradle/wrapper
      #       vlc-android/.gradle
      #       vlc-android/libvlcjni/vlc/contrib
      #     key: ${{ runner.os }}-vlc-build-${{ hashFiles('vlc-android/compile.sh', 'vlc-android/build.gradle') }}
      #     restore-keys: |
      #       ${{ runner.os }}-vlc-build-